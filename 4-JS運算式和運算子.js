//!            Javascript 運算式和運算子
//!#################################################
/*
?[運算式和運算子]
* 運算式(expresstion, 又稱表達式), 是JS的一種片語(phrase), 可被估算(evaluated)而產生一個值
* 簡單的運算式如變數, JS會估算指定給該變數的值
* 複雜的運算式是從簡單的運算式建構出來的, 如陣列存取運算式, 函式調用運算式
* 運算子(operator)可用來結合運算式, 以建構出更複雜的運算式

?[主要運算式]
* 最簡單的運算式, 稱為主要運算子(promary expresston), 為獨立存在, 內部不再包含任何更簡單的運算式
* -常數
* -變數參考
* -特定關鍵字
*   如true, false, null, this(估算目前的物件) 
* -字面值/直接量

?[物件和陣列的初始器]
* 物件和陣列的初始器為新創建的物件和陣列運算式
* 他們有時候被稱為物件字面值和陣列字面值, 但並非真正的字面值(他們之中包括了數個運算式, 並非主要運算式)
~ [1,2,3] //陣列初始器(array initializers)
~ {a:1, b:2} //物件初始器(object initializers)

?[函式定義運算式]
* 函式定義運算式(functional definition expression)定義了一個JS函式, 運算式的值即為新定義的函式本身
* 某種意義也是函式字面值(並非真正的字面值)
~ let x = function(){} //函式定義運算式

?[特性存取運算式]
* 特性存取運算式(property access expresion)估算物件特性(或陣列元素)的值
~ expression. identifier //運算式(變數參考或物件初始器, 指定物件) + 識別字
~ expression [expresstion] //運算式(指定物件或陣列) + 索引

$特性式條件存取運算式
* null, undefined為沒有特性的值, 若使用特性存取運算式, 會出現類型錯誤(TypeError)
* 你可以使用 ?. 或 ?.[] 為錯誤做防護
~ expression?. identifier //不再出現錯誤, 而是出現undefined
~ expression?.[expresstion] //不再出現錯誤, 而是出現undefined
* 使用利變數更改物件不會造成錯誤
* 選擇性串列(optional chaining)

?[調用運算式]
* 調用運算式(invocation expression)用來呼叫函式
* 調用運算式 = 函式運算式 + 引數運算式
~ expresstion(expresstion);
* 調用運算式的值為函式定義時設定return的值, 若沒有, 則回傳undefined
* 若調用運算式左括號前為特性存取運算式, 稱為方法調用(method invocation)

$條件式調用運算式
* 若你調用函式在null, undefined或其他非函式上, 會產生錯誤(TypeError)
* 使用 ?.()估算null, undefined或其他非函式會產生undefined而不會出現例外

?[物件創建運算式]
* 物件創建運算式(object creation expression) 會創建一個新的物件, 並調用一個函式(建構器, constructor)來初始化該物件的特性
~ new Object; //關鍵字new + 建構器函式(沒有引數括號可省略)
~ new Object(1, 2); //關鍵字new + 建構器函式

?[運算子概觀]
* 運算子用於:
*   算數運算式(arithmetic expresstions)
*   關係運算式(relational expresstions)
*   邏輯運算式(logcal expresstions)
*   指定運算式(assignment expresstions)
* 運算子表示:
*   標點符號表示
*   關鍵字表示

$運算元數目
* 運算元 = 運算子可結合的運算式
* 運算子可用運算元數目(元數, arity)來分類, 如一元運算子(unary operators), 二元運算子(binary operators), 三元運算子(ternary operators)

$運算元和回傳型別
* 某些運算子會預期運算元為特定型別, 並回傳特定某型別的值
* JS會自動轉換你的型別成預期的型別
* 某些運算子會依據運算元的型別而有不同的行為(如加號可把數值相加也可串接字串)

$運算子的副作用
* 某些運算子(如指定運算子, 遞增遞減運算子, delete)本身估算會影響到未來的估算
* 若在函式或建構器主體用到任何運算子有副作用, 那麼函式調用運算式和物件創建運算式就會有副作用

$運算子優先序
* 運算子優先序控制運算進行的順序, 較高優先序比較低的先運行
* 運算子優先序能以明確使用的括弧(parentheses)來覆寫
* 特性存取和調用運算式的優先序比任何運算子都還高
* 有些新的運算子(如??, **)優先序相對某些運算子並未被明確定義, 若要使用該運算子與某運算子混用, 須明確使用用算子

$運算子結合性
* 結合性代表優先序相同的執行順序, 分為左到右(L)和右到左(R)
* 指數, 單元, 指定和三元運算子有從右到左結合性, 其他的為左到右的結合性(如加減乘除)

$估算順序
* 運算式(x + y)優先序和結合性規範了複雜的運算式中, 運算進行的順序
* 子運算式(字面值x)的估算永遠以嚴格的左到右順序進行估算
~ w = x + y * z // 1. w, x, y, z被進行估算 2. y * z 進行運算, + x 值進行運算, 指定給運算是w所參考的變數或特性

?[算數運算式]
* 單元減號(-)和指數(**)會產生歧義(ambiguity), 必須加入括弧判斷順序, 否則出現語法錯誤
* 整數除整數(若不能整除)會出現浮點數(JS數字都是浮點數)
* 取餘數(%)通常用於整數, 但也能用於浮點數值

$加號運算子(+)
* 加號能用於相加數字或字串
* 兩運算元都為數字: 結果為數字
* 兩運算元都為字串: 結果為字串
* 加法賦予字串較高的優先序(數字 + 字串 -> 字串)
* 若其中運算元非數字或字串, 會經自動轉換再相加
* 結合性會影響到估算的結果

$單元算數運算子(+, -, ++, --)
* 單元加(unary plus, +)
*   將運算元轉換為數字(原先是數字則甚麼都不會做, 不可用於bigint)
* 單元減(unary minus, -)
*   必要時(因為可用在bigint), 將運算元轉換為數字, 並改變正負號
* 遞增(increment, ++)
*   運算元必須是一個lvalue(變數, 物件特性或陣列元素)
*   前遞增: 遞增運算元本身, 並估算遞增後的值(回傳遞增過後的值)
*   後遞增: 遞增運算元本身, 但估算未遞增的值(回傳原本的值)
* 遞減(decrement, --)
*   運算元必須是一個lvalue(變數, 物件特性或陣列元素)
*   前遞減: 遞減運算元本身, 並估算遞減後的值(回傳遞減過後的值)
*   後遞增: 遞減運算元本身, 但估算未遞減的值(回傳原本的值)

$位元運算子(&, |, ^, ~, <<, >>, >>>)
* 位元運算子以數字的二進位表示法進行低偕的位元操作(位元的布林運算)
* 位元運算子預期整數運算元(32位元數字), 必要時透過強制轉型(coerce, 將運算元轉為數字, 並捨棄小數部分以及超過第32位元的所有位元)轉換該數值為32位元.    
* 位元AND(&)
* 位元OR(|)
* 位元XOR(^)
* 位元NOT(~)
* 左移(<<)
* 有號右移(>>)
* 以零填補的右移(>>>)

?[關係運算子]
* 測試運算元間的某種關係
* 永遠返回boolean值

$相等性和不等性運算(==, ===, !==, !===)
* 嚴格相等性運算子(===): 是否全等(型別需相等)
* 相等性運算子(==): 是否相等(型別轉換)

$比較運算子(<, >, <=, >=)
* 若運算元非數字或字串, 會進行轉換
* 比較運算子數字優先性高於字串(不同於加號運算子字串優先性高於數字)

$in運算子
* in預期左運算元為字串或符號, 右運算元為物件
* 判斷左邊值是否為右邊物件的一個特性

$instanceof運算子
* instanceof預期左運算元是一個物件, 右運算元是別出一個類別的物件
* 當左運算元為非物件, 會回傳false, 當右運算元為非類別, 會擲出typeerror

?[邏輯運算式]
* 會進行布林代數運算

$邏輯AND(&&)
* &&並沒有規定運算元必須是boolean值:
*   當左邊運算元的值為假值: 整個運算式必為假值(程式不會估算右邊的值: 稱作短路), 回傳左邊的值
*   當左邊運算元的值為真值: 回傳右邊的值 
~ console.log(true && true); // => true
~ console.log(true && false); // => false
~ console.log(false && true); // => false
~ console.log(false && false); // => falss
~ console.log(null && 32); // => null //只估算左邊的值
~ console.log(null && null.x); // => null //只估算左邊的值(因為沒跳出typeerror)
~ console.log(44 && null); // => null
~ console.log(56 && 22); // => 22

$邏輯OR(||)
* ||並沒有規定運算元必須是boolean值:
*   當左邊運算元的值為真值: 整個運算式必為真值(程式不會估算右邊的值: 短路), 回傳左邊的值
*   當左邊運算元的值為假值: 回傳右邊的值

$邏輯NOT(!)
* 用途為倒轉其運算元的boolean值
* 不同於&&和||, 運算元倒轉前會被轉換為boolean(有規定運算元需為boolean), 意味著返回的值也為boolean
* 你可以套用NOT運算元兩次!!: 將任何的值轉為等效的boolean值

$迪摩根定律
~ let p;
~ let q;
~ console.log(!(p && q) === (!p || !q));
~ console.log(!(p || q) === (!p || !q));

?[指定運算子]
* =運算子用來指定值給變數或特性
* =運算子預期左運算元為lvalue, 右運算元為任意值
* 指定運算式的值就是右運算元的值
* 指定運算式有右到左的結合性: 可以使用 a = b = c = 3, 來一次指定一個值到多個變數

$帶有運算的指定
* JS支援帶有運算性質的指定運算子, 做為一種捷徑
* +=, -=, *=, /=, %=, **=, <<=, >>=, >>>=, &=, |=, ^=

?[估算運算式] 
$eval() - 一個被當作運算子的函式
* eval()可直譯一段JS原始碼字串, 並估算他們以產生一個值的能力
* eval()的動態估算在實務上幾乎是個強大但非必要的功能, 並可能會產生資安漏洞
* eval()會回傳該字串最後一個運算式或述句的值(如果程式碼無誤的話), 並且會使用程式碼的變數環境(eval()甚至還有變更該區域變數的能力)

$全域的eval() <- "呼叫端位於區域內"
* 當eval()是以eval以外的任何名稱被調用, JS直譯器會把該字串當作頂層的區域程式碼(top-level global code)來估算, 被估算的程式碼可定義新的全域變數或全域函式, 也可以設定全域變數, 但他不會使用或修改對於呼叫端函式是區域值的任何變數(因次不會干擾到最佳化動作)
~ const GlobalEval = eval; //使用另一個名字會進行全域的eval
~ let x = y = "global" //兩個全域變數
~ function f() { 
~   let x = "local";
~   eval("x = x + 'changed'"); //區域的eval 
~   return x;
~}
~ console.log(f(), x); // 印出localchanged global
~ function g() { 
~   let y = "local";
~   GlobalEval("y = y + 'changed'"); //全域的eval 
~   return y;
~}
~ console.log(g(), y); //印出local globalchanged

$嚴格的eval()
* 成為了保留字(更像運算子)
* 當eval()在嚴格模式中被呼叫, 或被估算的程式碼是以use strict指引開頭的, 那麼eval()就會以一個私有的變數環境進行區域性的eval. 被估算的程式碼可以查詢並設定區域變數, 但他無法在區域範疇中定義新的變數或函式.

?[其他運算子]
$條件運算子(?:, conditional operator)
* 唯一一個三元運算子
~運算元1 ? 運算元2 : 運算元3;
* ?號左邊期望boolean值:
*   當運算元1被轉換為true(運算元1是truthy): 運算元2被估算並回傳值 
*   當運算元1被轉換為false(運算元1是falsy): 運算元3被估算並回傳值

$首定義(??, first-defined, nullish coalescing)
* 首定義運算子??會估算他的第一個有定義(非null或undefined)運算元
* 可避免運用||取的非false時所遇到的問題(0, ""會被轉為false) 

$typeof運算子
* 使用typeof會回傳一個指出該運算元型別的字串 

$delete運算子
* 刪除指定運算元的物件特性或陣列元素
* 通常為了他的特性刪除副作用而使用, 而非為了他回傳的值
* 嘗試讀取被刪除的特性或元素會回傳undefined, 但並不代表該特性或元素的值為undefined, 而是該特性或元素已經不存在(可使用in運算子作判斷).
* 刪除陣列元素會在該陣列留下空洞, 並不會改變該陣列的長度(陣列是稀疏的(sparse))
* delete預期運算元為一個lvalue
*   若非ivalue, 不會採去任何行動而回傳true
*   若是ivalue並成功刪除, 則回傳true
*   若是ivalue沒有成功刪除, 則回傳false(如變數不可刪除)

$await運算子
* 預期一個Promise物件作為唯一的運算元
* 用於非同步程式設計

$void運算子
* void運算子會估算他的運算元, 然後捨棄該值, 並回傳undefined
* 僅在運算元有副作用時有意義

$逗號運算子
* 估算兩個運算元, 但僅會回傳第二個運算元的值(丟棄第一個)
* 可把兩個運算式壓縮成一個運算式
*/


