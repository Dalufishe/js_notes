//!           Javascript 型別, 值, 變數
//!#################################################
/*
?[型別, 值, 變數]
* 電腦程式運作 - 操作值(values)
* 值的種類 - 型別(types) 
* 程式需保留一個值供未來使用, 會將值指定(assigns)給一個變數(variable). 當需要使用值, 則可透過使用變數名稱指涉(refer)該值

?[概觀和定義]
* -原始型別(primitive types): 數字, 字串, 布林值, null, undefined, Symbol(ES6新增)
* -物件型別(object types): 原始型別之外的型別都是物件, 稱物件型別
*   -物件是特性(properties)的群集(collection). 
*   -最普通的物件, 特殊物件如array, Set, Map, typed array, RegExp, Date, Error, function, class等
*   -JS直譯器(interpreter)會進行自動的垃圾回收(garbage collection, 當沒有程式使用物件, 就會進行垃圾回收), 以管理記憶體(因此程序設計師不必擔心物件的物件的解構或解配置).
*   -JS支援物件導向的程式風格, 也就是說你可以使用物件型別之方法(method)取代全域函式(function)
* 原始型別值 - 不可變的(包括字串!)
* 物件型別值 - 可變的 ("變"指改變資料類型中的值, 而非變量的值)
* 可擁有方法類型: 對象類型, 數字, 字符串, 布林值
* 不能擁有方法類型: undefined, null
* JS會自由對值進行型別轉換
*   -當使用程式不期望的值, 程式會轉換成期望的值
*   -相等性運算子(==)會進行型別轉換, 然而嚴格相等性運算子(===)不會

?[數字]
* 不區分整數和浮點數 - 均以符點數表示
* 採用IEEE 754所定義的64位元浮點格式(floating-point format)(現代程式語言如C++, Java常用的double)
*   能表示±1.79~ x 10 308次方 ~ ±5 x 10 -324次方
*   能精算-2 53次方 ~ 2 53次方包括首尾(能使用BigInt精算更大的"整數")
* 然而某些運算是以32位元進行的 
* 數字為字面值/直接量
* 負號並非直接量的一部份, 為一元求返""運算符"

$整數型
* -十進制整數 - 數字序列
* -十六進制整數(hexadecimal) - 0x/0X + 十六進制數串(0 ~ 9, A/a ~ F/f)
* -二進位制整數(binary) - 0b/0B + 0/1字串
* -八進位制整數(octal) - 0o/0O + 八進位制數串(0 ~ 8)

$符點型
* -傳統寫法 - 整數 + 小數點 + 小數部分
* -指數寫法 - [整數 + 小數點 + 小數部分] + [E/e] + [+/-] 指數
*   表示實數乘10的指數次冪

$算數運算
* 加(+), 減(-), 乘(*), 除(/), 求餘(%), 取冪(**, ES6新增)
* Math物件提供之運算
* 數字運算結果
*   溢出/溢位(overflow), 下溢/欠位(underflow), 被0整除不會報錯
*   正數溢出: infinity
*   負數溢出: -infinity
*   正數下溢: 返回0
*   負數下溢: 返回"負零"
*   正數除0: infinity
*   負數除0: -infinity
*   零除零: NaN
*   其他大部分錯誤操作: NaN
* ECMAScript 5修正 infinity & NaN 錯誤: 更改為只可讀
* NaN誰都不相等, 包括自身 - NaN !== NaN // => true
* 判斷NaN - isNaN()函式
*   isFinite() 來判斷是否為有限數(並非NaN, Infinity, -Infinity)
* 零幾乎等於負零, 只有在作為除數不相等(無限大並不等於負無限大)

$二進制符點數所造成問題
* Javascript採用IEEE 754標準定義64位符點格式表示數字
* 某些情況, 你使用之實數僅為真實值的近似而已
*   符點僅能表示有限位數 (18,437,736,874,454,810,627位)
*   IEEE-754為二進位表示法, 無法精準表示如1/10的數字
* 造成問題
~   var x = .3 - .2;
~   var y = .2 - .1;
~   x == y; // => false
* 此種誤差極小, 仍能夠勝任大部分運算, 僅在比較兩值會出現問題

$BigInt (物件類別)
* ES2020定義的新功能, 能夠處理極大的整數
* 表示法: 數字 + 字母n
* 標準的運算子能用於BigInt, 但不可跟一般的數字混用(位元運算子可以混用)
* Math物件不接受BigInt

$日期跟時間 (物件類別)
* 可透過時戳(timestamp, 從1970-1-1開始所經過的毫秒)

?[文字]
* JS中用字串(String)表示文字
* 一個字串是16位元值的不可變有序序列
* 一個字串的長度為他所包含之16位元值的各數
* JS使用UTF-16編碼的Unicode字元集, 一個16位元值通常表示一個Unicode字元; 但少部分無法容納的Unicode字元, 則是使用UTF-16規則使用2個16位元值進行編碼, 這意味著長度為2的字串可能僅表示單一個Unicode字元.
* 大部分JS定義的字串操作方法均是用在16位元值上, 而非字元(然而ES6字串是可迭代(iterable)的, 他會迭代字元而非16位元值)

$字串字面值
* 單引號(可包含雙引號) or 雙引號(可包含單引號) or 重音符(backticks, `, ES6新增)刮起來的字符序列
* -多行顯示單行 - 結尾加上加號或反斜線(backslash, \)
* -顯示多行 - 反斜線n(\n) or 使用重音符

$轉義序列
* 反斜線字元(\) + 字元 - 轉義序列/跳脫序列(escape sequence, 表示原本在字串無法表示的字元)
* -\xXX: 2位16進制數指定 Latin-1字符
* -\uXXXX: 4位16進制數XXXX指定Unicode字符
* -\u{n}: 編碼位置n所指定的Unicode字元(ES6)
* -\n or \u000A: 換行符 
* -\v or \u000B: 垂直制表符
* -\f or \u000C: 換頁符
* -\r or \u000D: 回車符
* -\" or \u0022: 雙引號
* -\' or \u0027: 單引號
* -\\ or \u005C: 反斜線

$處理字串
* -加號(+)可將字串進行串接(concatenate)
* -length屬性可取得字串長度(所包含16位值的數)
* -charAt(index)方法可透過索引值取得字符 
*   -index = 0  可去得第一個字符
*   -index = string.length - 1 可取得最後一個字符
* -substring(start, end)方法可取得索引值start到end-1(不包含)的值
* -slice(start, end)方法可取得索引值start到end-1(不包含)的值
*   slice(-number)方法可取得最後number個值
* -split(string)方法可得透過string分割字串的子串
* -indexOf(string)方法可得字符string第一次出現的位置
*   indexOf(string, index)方法可得字符string在位置index後首次出現的位置
* -lastIndexOf(string)方法可得字符string最後出現的位置
* -startWith(string)方法可回傳布林值 - 是否以String開始
* -endwith(string)方法可回傳布林值 - 是否以String結束
* -includes(string)方法可回傳布林值 - 是否包含String
* -replace(A, B)方法可得將第一個出現的A改成B的"全新字串"(字符串無法改變)
* -replaceAll(A, B)方法可得將所有出現的A改成B的"全新字串"(字符串無法改變)
* -normalize("NFC", "NFD", "NFKD", "NFKC")方法將Unicode常態化(normalization, ES6)
* -toUpperCase()方法可得將所有字符轉變成大寫的"全新字符串"(字符串無法改變)
* -toLowerCase()方法可得將所有字符轉變成小寫的"全新字符串"(字符串無法改變)
* -padStart(len, string)方法可在左邊加入string, 直到長度為len
* -padEnd(len)方法可在右邊加入string, 直到長度為len
* -trim()方法可在頭尾移除空格
* -trimStart()方法可移除左邊的空格
* -trimEnd()方法可移除右邊的空格
* -concat(string)串接字串的另一種方法
* -repeat(n)將字串重複n次
* 字串是不可變的, 類似改變字串的方法, 實則返回新字串
* 字符串可當作只讀數組, 除了chatAt()方法, 也可使用方括號索引值(string[index])取得字符

$範本字面值
* ES6後, 字串能以重音符(backtists)來界定
* 不僅是字串字面值語法, 範本字面值(template literals)可包含任意的JS運算式(運算式的值會轉換成字串, 再和重音符中的字面值字元作結合)
* ${} 會被解讀成JS運算式

$模式比對
* 正規表達式(RegExp, regular expression)是一個強大的資料型別, 用於處理文字(描述字串模式並進行比對)
* 成對斜線(//)之間的文字構成了正規表達式字面值

?[布林值]
* 布林值代表真/假, 是/否, 開/關
* 值只有true和false(保留字)
~ a == 4;
*   比較語句來判斷變數a是否等於4, 若是, 返回true, 若不是, 返回false
* 布林值常常被用在控制結構中(如if/else)
* undefined, null, 0, -0, NaN, ""(空字串) - 會被轉換成false(和false本身被稱作假值(falsy value)), 除了這些之外其他值都會轉換成true(和true本身被稱作真值(truthy value))
* &&運算符執行了邏輯"與"(AND)操作 - 當操作數都為真值才會返回true, 否則返回false
* ||運算符執行了邏輯"或"(OR)操作 - 當操作數其中之一為真值返回true, 兩個都為假值則反回false
* !一元操作符執行了邏輯"非"(NOT)操作 - 當操作數為真值返回false, 假值返回true

?[null和undefined[]
* null為JS關鍵字, 用來表示空值
* 若使用typeof null, 結果會返回object, 也就是說, 可將null認為是特殊的對象, 含意是非對象, 但通常, 我們會認為null是它自有類型的唯一成員, 因為它可表示數字, 字串, 對象是"無值"的
* undefined並非JS關鍵字, 為預定義的全局常數, 值為未定義
* undefined用來表示更深層次的"空值" 
* -它是變量的一種取值, 表明變量沒有初始化
* -查詢對象屬性或數組元素若不存在, 返回undefined
* -函數沒有設定回傳值, 則返回undefined
* ECMAScript 3 undefined變量是可讀/寫的, 此錯誤在ECMAScript 5做了修正(只可讀)
* 若使用typeof undefined, 則返回undefined
* 使用相等運算符"=="認為兩者是相同的(使用嚴格相等運算符"==="才可區分他們)
* 轉換成布林值 -> false -> null, undefined為假值
* null, undefined都不包含任何屬性或方法, 使用"."和"[]"甚至會出現錯誤

?[符號]
* -ES6之前的版本, 物件的特性名稱一定是字串
* -ES6之後的版本, Symbol也可以作為特性名稱
* Symbol並沒有字面值語法, 要獲得Symbol值會呼叫Symbol()函式(永遠不會回傳重複的值(都是唯一的值), 不用擔心被覆寫(可以使用Symbol.for()取得重複的值))
* Symbol函式接受一個字串作為引數(Symbol("Hello"))並回傳唯一的Symbol值(Symbol(Hello)). 若將Symbol轉回字串, 則原本的Symbol會被包在字串中("Symbol(Hello)")

?[全域物件]
* JS解釋器啟動時(或Web加載新頁面時), 將創建一個新的全域物件, 並給予一組定義的初始特性(並不是保留字, 但應當作保留字對待)
* -全局常數: undefined, Infinity, NaN... (非保留字, 但應作為保留字對待)
* -全局函數: isNaN(), parseInt(), eval()...
* -構造函數: Date(), RegExp(), String(), Object(), Array()...
* -全局對象: Math, JSON.
* 全局對象的特性是全局定義的識別字, 在JS程序可以直接使用..
* 客戶端JS, Windows對象定義了些額外的全局屬性
* 可在代碼最頂級(最外圍)使用關鍵字this引用全局對象
* 客戶端JS, Windows對象充當了全局對象, 並且有個windows屬性引用其自身, 可替代this來引用全局對象
* 程式碼中聲明的全局變量, 會成為全局對象的一個屬性

?[包裝物件]
* JS對象是種複合值, 為"特性"或已命名值的集合
* JS透過"."引用對象之屬性值
* 當屬性值為函數時, 我們稱之為"方法"(method)
* 字符串並非對象, 為甚麼會有屬性?
*   因為當你引用字串的屬性(但字串沒有屬性), JavaScript就會自動將字串通過調用new String(字串)轉換成對象, 並用來處理屬性的引用, 一旦引用結束, 新創的對象就會銷毀(臨時對象) 
*   數字與布林值也有各自的處理方法(通過Number()和Boolean()構造函數創建臨時對象), 但null和undefined病媒有包裝對象(訪問屬性會造成錯誤)
~ var s = "Eason"; //建立字符串
~ s.len = 4; //建立屬性
~ var t = s.len; //訪問屬性並儲存
* t值為undefined, 為甚麼?
*   第二行建立的字符串對象, 在該行結束隨即銷毀 - 第三行將重新建立字符串對象, len屬性自然不存在, 結果為undefined
* 因此, 當你使用包裝對象(臨時對象), 並不能給予新屬性(會被銷毀), 只能將舊屬性讀出來
* JS會在必要時將包裝對象轉換成原始值(有些情況兩者被視為一樣)
*   new String("hi") == "hi" >> true //等於運算符視為相等
*   new String("hi") === "hi" >> false //全等運算符視為不等
*   通過typeof可明顯看出兩者明顯差異(new String("hi") - object, "hi" - string)

?[不可變的原始值和可變的物件引用]
/*
* -JS中的原始值(Number, String, Boolean, null, undefined的值)不可更改
*   字符串看起來像由字符組成的數組, 我們期望通過指定索引來修改字符串的字符, 但JS禁止這樣做 
*   字符串中的所有方法看上去返回了一個修改後的字符串, 實際上返回的是一個新的字符串值
* -JS中的原始值的比較為值的比較
* -JS中的對象(Object)中的值是可修改的
* -JS對象的比較並非值的比較
*   兩個對象包含同樣的屬性和相同的值(看起來兩對象是相等的), 但實際上是不相等的
* 我們通常稱對象為參考/引用類型(reference type), 對象值都是參考/引用, 對象的比較都是引用的比較, 且當他們引用同一個基對象時, 它們才相等
~   var a = [1,2,3]; //定義一個引用[1,2,3]數組的變量a
~   var b = a; //變量b引用同一個數組
~   b[3] = 4; //透過變量b修改引用的的數組 - [1,2,3] (變量a也會更著改變)
~   console.log(a[3]); //變量a也會修改
~   console.log(a === b);
* 當你想得到對象的副本或者比較兩個單獨的對象, 則需透過操作屬性或元素

?[型別轉換]
* JS會將傳入的值自動轉換成它所需要的值
$原始值轉原始值: 
* 書本第50頁(Boolean: 真值轉換成true, 假值轉換成false
*           String: 轉換成字串
*           Number: 轉換成數字, 轉換無意義則返回NaN,
*                    數字表示的字符串可直接轉換成數字(允許開始結尾添加空格)
*                   true轉換成1, false轉換成0)

$轉換和相等性
* 相等性運算子(==): 會進行轉換 (彈性)
* 嚴格相等性運算子(===): 型別一樣值一樣才會相等 (嚴格)
* 一個值對另一個值得可轉換性(convertibility)不代表兩個值的相等性(使用==也一樣, 如undefined可被轉換成false, 但undefined == false // => false)

$明確的轉換
* -Number()函式 - 手動轉換數字
* -String()函式 - 手動轉換字串 //也可使用toString()方法(null, undefined不能用)
* -Boolean()函式 - 手動轉換布林值
* 上述函式也可作為建構器(constructor使用), 使用new來調用會得到包寡器(wrapper)物件
* toString()方法可放入基數(base)作為引數, 將數字轉換為某進位表示的字串
* 處理金融或科學計算, 常常將數字轉換為字串來控制小數位數或指數記號.  JS定義了toFixed() - (小數點後顯示幾位), toExponential() - (小數點後幾位透過指數顯示(小數點前僅一位)), toPrecision() - (指定以多少有效位數顯示字串)方法來進行這種數字對字串的轉換(均會四捨五入)
* parseInt(), parseFloat()全域函式可剖析不同進位以及忽略字串中要轉換成數字
*後方無關的字元, 並可指定轉換的基數.

$物件轉原始值
!<演算法>
* -prefer-string(偏好字串)演算法: 回傳原始值, 優先選用字串
* -prefer-number(偏好數字)演算法: 回傳原始值, 優先選用數字
* -no-preference(無偏好演算法): 無偏好, 可自訂義

!<型態轉換使用的演算法>
* 物件轉Boolean: 不需使用上述演算法, 全部回傳true, 並適用所有物件(包括空字串 - 和相等性無關, 此為可轉換性)
* 物件轉字串: 優選選用偏好字串演算法, 必要的話將原始值轉為字串(因為你使用了"偏好"字串演算法, 然而實際上可能未得到字串)
* 物件轉數字: 優先選用偏好數字演算法, 必要的話將原始值轉為數字(因為你使用了"偏好"演篹演算法, 然而實際上可能未得到數字)
* 特例的運算子轉換: 
*   +運算子會使用無偏好演算法將物件轉換成原始值. 有兩個原始值後, 會檢查'他們的型別, 若其中一個式字串, 另一個則轉換成字串, 反之數字則亦然.
*   ==, !=運算子會使用無偏好演算法將物件轉換成原始值, 再進行比較
*   <=, <, >, >=會使用偏好數字演算法(回傳值不會被轉為數字)

!<toString()和valueOf()方法>
* 用於物件的toString()方法在預設情況回傳不盡人意, 因此許多型別定義更特定版本的toString()方法: 
*   -Array.toString() -> 利用逗號將每個陣列元素串連在一起
*   -Function.toString() -> 使用者定義的函式轉為JS原始碼字串
*   -Date.toString() -> 人類可讀並JS可剖新的日期與時間字串
*   -RegExp().toString() -> 轉換成看起來像RegExp字面值的字串 
*valueOf()會將物件轉換成能表示該物件的一個原始值, 若該物件存在的話. 但物件為複合值, 大多數情況無法表達為單一原始值, 則回傳物件本身.
*   -包裹器類別(String, Number, Boolean)會回傳物件所包裹的原始值
*   -Array, Function, RegExp回傳物件本身
*   -Date較特別, 會傳該日期的內部表示值: 從1970/1/1算起的毫秒數

!<利用上述2種方法實現物件轉原始值演算法>
* prefer-string: (取決於你須要轉成字串)
*   1. 嘗試toString()方法 -> 如果有定義並回傳一個原始值 - "使用該值" - 若失敗: 嘗試valueOf()方法
*   2. 嘗試valueOf()方法 -> 如果有定義並回傳一個原始值 - "使用該值" - 若失敗: TypeError
* prefer-number: (取決於你須要轉成數字)
*   1. 嘗試valueOf()方法 -> 如果有定義並回傳一個原始值 - "使用該值" - 若失敗: 嘗試toString()方法
*   2. 嘗試toString()方法 -> 如果有定義並回傳一個原始值 - "使用該值" - 若失敗: TypeError
* no-preferenve: (若轉換並非固定, 取決於本身)
*   如Date物件使用prefer-string, 其餘的內建型別使用prefer-number

$變數的宣告和指定
* 運用名稱, 也就是識別字(identifiers), 繫結(bind)到一個值上, 讓我們有辦法參考(refer. 或稱指涉)該值. 
* 簡單來說就是把值指定給一個變數
* 變數一般來說是可變的. 使用常數可將一個值永久指定給一個名稱

* 你必須宣告(declare)一個變數以使用他
* 宣告時可指定初始值(initial value)
* 若變數僅宣告, 尚未賦值, 值為undefined
* 你可以使用let宣告變數. 當你宣告常數時, 使用const(必須初始化).
* 常數有兩種學派 - 1.將必定不會改變的值(如物理常數)設為const 2.將所有值都宣告為const, 只有少數要改動的值設為let

!<變數和常數範疇>
* 範疇(scope)只原始碼中該變數有定義的區域
* let 和 const 都是區塊範疇(block scoped, 指在一組大括號內(curly braces))
* 當宣告出現在頂層(top level, 所有程式碼區塊之外), 我們稱之為全域(global)的常數或變數, 並有全域範疇.
*   在Node中全域變數範籌為定義的該檔案(flie), Web中為定義的該HTML檔案(所有<script>都共通)

!<重複宣告>
* 同一個範疇中, 重複使用let或const宣告會造成語法錯誤(syntax error)
* 內嵌範疇中(nested scope)以同名宣告是可行的(最好避免)
* 在原版JS中, 變數宣告和指定型別並無關係(不像Java, C等靜態語言)

!<使用var宣告>
* ES6之前的版本, var是宣告變數的唯一方法
* 使用var宣告的變數沒有區塊範疇, 而是以包含他們的函式為主體
* 在全域範圍使用var, 他所宣告的就是全域變數, 但和let宣告有個重大差異 - 以var宣告的變數為全域物件的特性, 可透過globalThis來參考(無法透過delete刪除)
* var可在同個範疇重複宣告變數(常常使用, 因為var變數為函式範疇)
* var - 拉升(hoisting): 當一個var變數被宣告, 該宣告會被往上提到包含他的函式之頂端, 但初始化仍停留在撰寫他的地方(因此可在外圍函式(enclosing function)作使用, 但在初始化前值為undefined, 並不會出現錯誤).

*如果你沒有使用const, let, var宣告變數(未宣告), 你會創造出一個全域變數(和var全域變數一樣為全域物件的特性, 但可被delete刪除), 無論內嵌有多深(嚴格模式下被禁用, 出現參考錯誤)

$解構指定
* ES6實作了種複合的宣告和指定語法, 稱為解構指定(destructuring assignment)
~ let [x,y] = [1,2]; // 等同於 let x = 1, y = 2
~ [x,y] = [x+1,y+1]; // 等同於 x = x + 1, y = y + 1
~ [x,y] = [y,x]; // 對調兩變數的值
* 左邊多餘的變數會變為undefined, 右邊多餘的變數會被省略, 也可透過逗號跳過變數或值
* 你可以過3個點...收集沒用到的值到一個變數中
* 可透過巢狀陣列進行解構指定
* 任何可迭代的結構都可以解構, 不侷限於陣列 
~ let [x,y] = "hi";
* 右邊若是物件值, 也可進行解構, 左邊需使用類似物件字面值的表示法
~ let {what, the} = {what: 12, is: 21, the: 53, stuff: 35} //左邊的what, the對應what, the特性, 並且變數名稱也為what, the
~ let {what: w, the: t} = {what: 12, is: 21, the: 53, stuff: 35}左邊的what, the對應what, the特性, 變數名稱為w, t
*/



